##### 1.网页一直加载中可能原因有哪些？你是如何定位的？

前端：

- 代码逻辑问题

- 静态资源：图片/视频等媒体文件过大、js 文件未压缩、图片未使用预加载等

后端：

- 业务代码：代码逻辑问题、业务逻辑中缺乏分块处理

- 数据库问题：数据量大查询缓慢、数据库无索引全盘扫描、无缓存每次都需要查询数据库

网络问题：

- DNS 解析问题、带宽小，传输数据大、客户端网络延迟大、网络中断或卡顿

硬件设备：

- 服务器设备差、服务器过载或维护中、网页被拦截

##### 2.点击某个按钮无反应，一般是什么原因你是如何判断的？

- 是否发起请求：否-前端；

  - 是：发出的请求格式、内容是否与接口定义一致？否：前端
  - 是：是否收到网络返回值（response 中的是否有响应值）？否：后端
  - 是：返回值格式是否符合接口定义？否：后端；是：前端

- 网络卡顿（弱网）

- 浏览器版本不兼容

- 无权限

##### 3.浏览器中输入一个 url 会发生什么？

- 进行 DNS 解析获取 IP 地址-浏览器缓存、系统缓存（浏览器会进行系统调用(windows 中是 gethostbyname)，查找本机的 hosts 文件）、路由器缓存有直接返回 IP 打卡页面

- 判断是否有缓存，有直接打开页面

- 浏览器与目标服务器进行 3 次握手建立 TCP 连接

TCP 三次握手建立连接：

第一次握手： 客户端向服务器端发送报文

证明客户端的发送能力正常

第二次握手：服务器端接收到报文并向客户端发送报文

证明服务器端的接收能力、发送能力正常

第三次握手：客户端向服务器发送报文

证明客户端的接收能力正常

- 客户端向服务端发送请求（HTTP 请求）

- 服务器处理请求（服务端接收到请求后处理并返回一个响应）

某些服务器会做永久的重定向响应（对于大型网站存在多个主机站点负载均衡往往不会直接返回请求页面而是重定向 3 开头重定向 301、302

- 浏览器页面显示，对响应数据进行渲染

##### 4.常用 linux 命令

- ls：查看当前目录下的所有文件和子目录

- pwd：查看当前目录的路径，返回当前用户所在的目录路径

- pdwx XX：显示指定进程当前的工作目录

- cd：切换目录（cd /xx/xx）

- ```python
  cd和cd ~返回到家目录
  cd ..：返回到上级目录
  cd /XXX：需要进入的目录
  ```

- mkdir：创建新目录（mkdir directory_name）

- ```python
  mkdir 目录名
  ```

- rmdir：删除空目录（rmdir directory_name）

- rm：删除文件或目录

​ rm file_name

​ rm -r directory_name：递归删除目录及其内容

- cp：复制文件或目录

​ cp source_file destination

​ cp -r source_file destination：递归复制目录及其内容

- mv：移动或重命名文件或目录（mv old_name new_name）

- touch：创建空文件或更新文件的时间戳（touch file_name）

- cat：连接和显示文件内容（cat file_name;cat rank_test.py）

- more/less：逐页显示文本文件内容，用于查看大文件可翻页查询（more file_name;less file_name）

- head：默认展示前 10 行，通过-n 指定要显示的行数
- tail：默认展示文件后 10 行，通过-n 指定要显示的行数，通常用于查看日志文件的最新内容
- cat：连接文件并打印到标准输出，通常用于展示整个文件的内容，可以用来创建、合并文件

  head -n 10 file_name：显示文件的前 10 行

  tail -n 20 file_name：显示文件的后 20 行 tail -f

  cat a.txt cat file1 file2 将文件 1 和文件 2 的文件连接起来并输出到标准输出 cat a.txt b.txt 输出 a.txt 和 b.txt 文件的内容

  more a.txt less b.txt

- 文件追加 echo > filename：如果文件不存在则创建新文件，如果文件已存在则会覆盖原有内容

- ```python
  echo "需要写入的数据" > 文件名
  ```

- echo >> filename：将数据追加到文件末尾而不覆盖原有内容

- ```python
  echo "需要写入的数据" >> 文件名
  ```

- vim filename：打开文件编辑器输入要存入的内容，点击 Esc，：qw，保存即可

- ```python
  vim 文件名
  写入需要的数据
  按下Esc
  输入:qw
      点击enter
  ```

- tail -f 动态查看日志（tail -500f 文件名）显示最后 500 行内容，并实时跟踪文件的新增内容

- 查看文件内容 head cat tail more less sed

- 查看端口号：netstat anp | grep

- 改变文件权限：chmod

- ps：查看当前正在运行的进程

  - ps -e：列出所有进程，不仅当前终端
  - ps -f：显示完整进程信息，包括 UID、PID、PPID、C、STIME
  - ps -aux 或 ps -ef：显示所有进程的详细信息，包括所有用户的进程
  - ps -u username：显示特定用户的进程
  - ps -p PID1,PID2：显示特定 ID 的进程（户、PID、父进程 ID、启动时间、终端、执行时间和命令）

- 查看日志关键字：grep "关键字" 文件名

- 查看日志遇到过什么类型的错误：errors fail Exception

- 系统性能指标：top free df

- top：动态显示当前系统资源的使用情况和进程信息，实时更新，显示占用 CPU 和内存做多的进程---q 键退出

- | 上一条命令的输出，作为下一条命令参数(输入)

- ll：**显示当前目录下的文件和文件夹的详细信息**，以列表的形式显示文件的权限、所有者、所属组、大小、创建时间等

##### 5.数据库常用语法

- 增加：**insert into value**

- ```sql
  insert into 表名 (列1, 列2, 列3, ...)value (值1, 值2，值1，... )

  注意：指定库：库名.表名
  inser into likeshop.la_uesr ('id', 'nickname', 'uesrname', 'mobile') value (',', '用户1', '张朵', '13723132774');
  ```

- 删除：**delete from where**

- ```sql
  delete from 表名 where 条件

  delete from likeshop.la_user where id = '1';

  ```

- 修改/更新：**update 表名 set 列 1=值 1，列 2 = 值 2 where**

- ```sql
  update 表名 set 列1=值1,列2 = 值2 where  条件

  update likeshop.la_uesr set uesrname = '张三', mobile = '18348451569' where id = 1
  ```

- 查询：**select**

- ```sql
  1.查询手机号为18348451569的用户
  select likeshop.la_user from mobile = '18348451569';
  ```

- 去重查询：**select distinct 条件 from**

- ```sql
  select distinct 条件1, 条件2 from 表名

  SELECT DISTINCT mobile FROM `la_user`
  ```

- 排序查询：**desc 倒序 、asc 正序**

- ```sql
  select 条件 from 表名 order by 排序条件

  students表，包含id、name和age列。现在我们想按照年龄对学生进行升序排序，如果年龄相同，则按照姓名进行降序排序
  select id name age from students order by age asc, name desc

  la_buiness表中包含mobile, business_name, address按照buiness_name正序排列，店铺名字一样按照手机号倒序排列吧
  SELECT mobile, business_name, address FROM la_business ORDER BY business_name ASC, mobile DESC;
  ```

- 限制查询个数

- ```sql
  SELECT mobile, business_name, address FROM la_business WHERE business_name = '哈哈家政' LIMIT 1;
  ```

常用 adb 命令

- adb devices:查看连接设备

- adb install 包名.apk:安装应用

- adb uninstall com,yykuaile.sh(包名)：卸载应用

- adb shell pm list packages:列出手机装的所有 app 的包名

- adb logcat:查看日志

- adb reboot:重启手机

- adb push<电脑上的目录><设备里的文件路径>:从本地复制文件到设备

  eg：adb push test.flv/sdcard/test/good.flv

- adb shell pm list packages -s :列出系统应用的所有包名
- adb shell pm list packages -3 :列出系统应用的所有第三方包名
- adb start-server:启动服务器
- adb kill-server:停用服务器

##### 5.python 目录下的**init**.py 的作用

```python
1.__init__.py是用来初始化初始化Python包的/package包的
①初始化包
	导入包中的其他模块
	定义包级变量或函数
	执行其他初始化任务
 ②指定包的默认模块：**如果包中存在同名的模块（例如 mypackage/mypackage.py），则 __init__.py 可以通过以下方式指定该模块为包的默认模块：
Copy
# __import__("mypackage.mypackage")
③控制包的导入行为：__init__.py 文件可以包含代码来控制包的导入行为，例如：
    限制对某些模块的访问
    重新定义模块名称
    执行条件导入
2.初始化是指在使用对象或变量之前对其进行设置或配置的过程
3.初始化的重要性
	确保对象在使用前处于已知状态
	防止意外行为或错误
	提高代码的可读性和可维护性
```

##### 6.sql 分组、求和、排序、取数据

##### 6.1 接口自动化测试框架是怎么实现的

> python+pytest+request+allure
>
> 1.设计框架结构：common、config-配置目录、img、data、testcase、report、conftest.py：pytest 的配置文件，存放 fixture
>
> 2.安装所有依赖：pytest 测试框架、requests 发送 HTTP 请求、allure-pytest 生成测试报告、pyyaml
>
> pip install -i
>
> 3.请求封装：将 HTTP 请求的逻辑封装成一个通用的类
>
> 4.准备测试数据
>
> 5.编写测试用例
>
> 6.`conftest.py` 来定义一些 `pytest` 的 fixture，例如初始化客户端或者管理全局变量。
>
> 7.执行测试用例生成测试报告
>
> pytest -s testcase/XXX -- --alluredir=report
>
> allure generate report -o report/api_report
>
> allure serve report：生成本地文件

##### 6.2 给定一个登录接口返回 token，后续接口怎么调用

> 将登录接口封装在 conftest 文件中，使用@pytest.fixture 后续接口调用时直接传入接口即可
>
> pytest.fixture 机制：fixture 是一种用来管理测试依赖和资源的机制，使用方式在函数钱加上@pytest.fixture

##### 7.python 中查看 errors 关键字的信息

- 使用【help】函数

```python
help(errors)
```

- 使用【dir】函数

```python
dir(errors)
```

##### 8.自动化测试用例如何实现（搭建自动化测试框架的信息）

##### 9.python 的线程和进程区别

##### 10.python 中如何判断一个字符串是回文

- 回文：从前往后读和从后往前读都相同的字符串

- 使用切片和比较

- ```python
  def is_palindrome(string):
      return string == string[::-1]
  ```

- 使用内置函数[reversed】]

- ```python
  def is_palindrome(string):
      return string == ''.join(reversed(string))

  ```

- 使用正则表达式

- ```python
  import re

  def is_palindrome(string):
      return bool(re.match(r'^[a-zA-Z0-9]*$', string) and string == string[::-1])

  ```

##### 11.python 中时间复杂度和空间复杂度是什么

- **时间复杂度**：衡量算法执行所需的**时间**，通常表示为大 O 符号。它描述了算法随着输入规模（通常表示为 n）的增长而运行所需时间的增长速率。
- **空间复杂度**：衡量算法执行所需的**内存空间**，也表示为大 O 符号。它描述了算法随着输入规模的增长而使用的内存空间的增长速率。

##### 12.微信小程序如何测试

首先，小程序测试和普通的手机端 app 项目和 web 端项目差不多，核心还是测试项目的业务逻辑，基本的功能测试。当然有不同的地方，我简单说一下：首先是兼容性： 1 兼容性问题要考虑到 Android 和 IOS 系统，以及最新的手机版本。 2 分辨率兼容要注意到，微信小程序定义的一个新的尺寸单位 rpx。 3 测试时需要考虑微信兼容，微信小程序的 SDK 一直在更新，测试时需要确定小程序使用的库在哪些微信版本号上支持。如果涉及交易这块，小程序和微信的钱包，卡包是可以交互的，需要验证各种交易场景。再就是权限这块，需要考虑到微信的授权。

##### 朋友圈测试点

1.功能测试：朋友圈发送

只发生文本（文本为空、文本长度限制、文本类型、是否支持粘贴）

发送图片（本地相册/拍摄、图片数量验证 1-9 张、图片格式 jpg\png）、图片尺寸、大小、图片预览、增删改、删除

发送视频（本地相册/拍摄、视频数量 1 个、视频格式、视频大小、增删改、为空）

文本+图片、文本+视频、内容限制、所在位置、谁可以看、提醒谁看、取消发布

##### 优惠券测试点

> 1.**基本功能测试**
>
> **优惠券生成**：验证系统是否能够正确生成优惠券，包括代码、折扣金额或比例、有效期等。
>
> **优惠券适用性**：测试优惠券是否适用于特定的商品、品类或订单金额。
>
> **优惠券类型**：确认不同类型的优惠券（如满减、折扣、买一赠一等）是否能正常使用
>
> 2.**优惠券使用测试**
>
> - **正常使用场景**：在符合条件的情况下使用优惠券，检查折扣是否正确应用。
> - **不符合条件场景**：尝试在不符合条件的情况下使用优惠券，检查系统是否正确拒绝并显示相应提示。
> - **多个优惠券使用**：测试在同一订单中使用多个优惠券的情况（如果系统支持），确认是否能正确计算总折扣。
>
>   3.**有效期测试**
>
> - **有效期内使用**：在优惠券有效期内进行测试，确保可以成功使用。
> - **过期使用**：尝试在优惠券过期后使用，检查系统是否能正确拒绝并提示用户。
> - **即将到期**：测试临近有效期的优惠券，观察系统是否提醒用户。
>
> ### 4. **用户体验测试**
>
> - **界面显示**：优惠券相关信息（如输入框、适用商品、折扣信息）是否清晰可见。
> - **使用提示**：用户在输入优惠券时，系统是否能及时反馈使用情况（如“优惠券已应用”或“优惠券无效”）。
> - **错误信息提示**：测试不同错误场景下系统是否能给出准确、友好的提示信息。
>
> ### 5. **安全性测试**
>
> - **优惠券代码破解**：测试系统对优惠券代码的安全性，确保不会被轻易猜测或破解。
> - **防止滥用**：验证系统对同一用户或账户使用同一优惠券的限制，避免恶意用户滥用优惠。
> - **数据保护**：检查优惠券生成和使用过程中的数据安全，确保用户信息不被泄露。
>
> ### 6. **兼容性测试**
>
> - **不同平台**：在不同的设备（PC、手机、平板）和浏览器上测试优惠券功能的兼容性。
> - **不同操作系统**：确保优惠券功能在不同操作系统（iOS、Android、Windows 等）上表现一致。
>
> ### 7. **性能测试**
>
> - **高并发使用**：在高并发情况下（如促销活动期间）测试系统的响应速度和稳定性。
> - **压力测试**：模拟大量用户同时请求优惠券的场景，确保系统能承受高负载。
>
> ### 8. **数据准确性测试**
>
> - **统计数据**：验证系统对优惠券使用情况的统计是否准确，确保能够正确记录使用次数和用户。
> - **财务结算**：测试折扣应用后，结算金额是否准确，确保用户实际支付金额与预期一致。
>
> ### 9. **第三方接口测试（如适用）**
>
> - **支付接口**：如果优惠券涉及到支付接口，需测试在应用优惠券后，支付流程是否正常。
> - **积分系统**：如果优惠券与积分系统相关联，验证积分计算是否准确。
>
> ### 10. **回退机制测试**
>
> - **订单取消**：如果用户取消订单，检查系统是否能正确处理优惠券的回退。
> - **退款流程**：在退款情况下，确保优惠券的使用记录和状态得到正确更新

##### 下单接口测试点

> 1.基础功能测试
>
> 入参全部有效能否正确生成订单且订单信息是否正确
>
> 入参无效/空/缺失，接口是否返回正确的信息
>
> 2.边界值测试
>
> 订单金额为 0 或负数，商品单价为 0 或负数
>
> 最大和最小数量验证（限购）
>
> 库存为 0
>
> 3.异常场景
>
> 商品 id 无效/已下架商品
>
> 超过库存数
>
> 用户未登录能否下单
>
> 网络断开或超时
>
> 4.安全性测试
>
> 身份验证、
>
> 数据加密：验证敏感数据是否加密（如支付信息、用户信息-账号密码）
>
> 放攻击性测试
>
> 5.性能测试：并发测试、负载测试
>
> 6.数据准确性测试
>
> 订单状态：下单后系统能否正确更新订单状态
>
> 财务记录：检查订单生成后相关的财务信息是否准确-总金额、折扣等
>
> 7.接口返回结果验证
>
> 返回格式：接口返回格式是否符合于其，必要的字段
>
> 返回信息准确性：成功下单和失败下单时返回的信息是否正确和完整
>
> 8.用户体验测试
>
> 接口返回成功或错误时是否有清晰的提示信息
>
> 下单的接口响应时间是否在可接受范围内
>
> 9.优惠券和促销活动
>
> 下单时使用优惠券系统能否正确验证和应用优惠
>
> 验证在促销活动期间下单系统能否正确处理相关的折扣和促销规则

##### 支付流程测试点

> 1.基础功能测试
>
> 能否正常发起支付请求且返回正确的支付状态-成功、失败、超时等
>
> 支付方式是否支持多种选择，银行卡、微信、积分等
>
> 支付结果能否及时反馈给用户，订单号、支付时间、支付金额等
>
> 支付金额是否正确、支付记录能否被正确保存和查询
>
> 2.兼容性
>
> 支付功能是否能实现不同的操作系统和浏览器、不同屏幕的尺寸和分辨率
>
> 支付在不同的网络环境下能否支付成功 wifi、5G 等
>
> 支付功能是否和其他应用进行良好的交互，指纹支付和人脸支付等
>
> 3.安全性
>
> 支付数据是否加密
>
> 支付页面是否有防止 SQL 注入等常见的网络攻击
>
> 4.容错性
>
> 支付过程中中断是否能够回退到上一步或退出支付流程
>
> 支付密码输入错误是否有友好提示
>
> 支付过程中网络断开能否重连或重新发起支付请求
>
> 支付时系统异常能否给出合理的错误码、是否有退款机制
>
> 5.用户界面友好、直观
>
> 同一笔订单是否可以多次支付、退款是否可以大与订单金额、订单是否可以分批次退款、支付使用优惠券时待付款金额和数据库的金额是否正确、支付时的优惠券是否可以通过抓包替换优惠券 id，过期优惠券能否使用

##### 支付接口测试

> #### **接口功能测试**
>
> - 接口可用性
> - 确保支付接口可访问，返回正确的状态码（如 200）。
> - 正确参数测试
> - 测试传递所有必需参数，确保返回正常结果。
> - 参数验证
> - 测试缺少必需参数时，接口是否返回相应的错误信息。
> - 测试参数格式错误（如金额为负值、无效的手机号等）时，接口是否返回相应的错误信息。
>
> #### 2. **异常情况测试**
>
> - 无效订单
> - 提交无效或过期的订单号，检查接口是否正确返回错误信息。
> - 重复支付
> - 对同一订单重复调用支付接口，验证接口是否能正确处理（如返回“订单已支付”）。
>
> #### 3. **边界值测试**
>
> - 金额边界
> - 测试最低金额（如 0.01 元）和最高金额（如超出平台规定的限额）是否正常处理。
> - 超长输入
> - 测试输入参数的最大长度（如描述、备注等），确保接口能够处理。
>
> #### 4. **安全性测试**
>
> - 权限验证
> - 测试未授权的请求是否被拒绝（如未登录用户）。
> - SQL 注入
> - 检查输入参数是否能防止 SQL 注入攻击。
> - XSS 攻击
> - 验证接口是否能防止跨站脚本攻击。
> - 敏感数据加密
> - 确保敏感数据（如支付信息、用户信息等）在传输过程中被加密（如 HTTPS）。
>
> #### 5. **性能测试**
>
> - 并发测试
> - 在高并发情况下调用支付接口，验证系统的响应时间和稳定性。
> - 压力测试
> - 逐渐增加请求量，测试接口的承载能力和瓶颈。
>
> #### 6. **返回结果测试**
>
> - 返回格式
> - 验证接口返回结果的格式是否符合规定（如 JSON/XML）。
> - 状态码验证
> - 确保接口在不同情况下返回正确的状态码（如成功、失败、未授权等）

##### 积分测试点

> 1.积分获取
>
> 下单获取积分、促销商品获取积分、支付方式获取积分、积分获取上线
>
> 2.积分使用
>
> 积分抵扣规则、最低消费限制、积分使用上限、部分积分抵扣、积分使用范围
>
> 3.积分有效期
>
> 有效期内的积分能够使用、快到期的积分是否有提示信息、过期积分是否自动扣除且不能使用
>
> 4.积分账户记录
>
> 有详情记录积分获得和使用记录、积分同步-测试登录不同设备时积分是否同步、积分冻结与解冻
>
> 5.取消订单和退货
>
> 取消订单积分是否返还给用户账号、部分退款积分是否按照比例退还、退货获取的积分是否扣除
>
> 6.积分规则和权限
>
> 不同等级的会员获得的积分数量是否不同、符合条件的用户才能获取积分（登录用户、会员用户、白名单用户）
>
> 7.安全性测试
>
> 积分交易防篡改、积分使用安全
>
> 8.异常情况测试
>
> 并发下积分一致性-模拟高并发场景，确保积分在多个订单同时支付时数据一致，避免积分计算错误或重复发放。、网络中断-网络中断的情况下，测试积分获取和使用是否能正确恢复或回滚。

##### 用户钱付了，前端页面显示支付失败 请问这是前端的原因还是后端的原因

> 一般可以通过以下方式来定位是前端还是后端问题
>
> 首先支付检查后端的支付处理日志，确定支付成功的状态是否正确返回给前端，如果没有正确返回给前端则是后端问题（逻辑或者支付网关的接口返回不正确）、如果正确返回了可能是前端逻辑有问题，第二点是前端缓存问题
>
> 检查数据库对应订单的支付状态是否更新如果没有更新则是后端
>
> 支付网关问题，如果后端通过第三方支付网关处理支付，如果支付网关出现问题或延迟，导致支付成功的状态没有正确返回给后端，前端收到的仍是支付失败的状态
>
> **请求超时或未正确响应**：前端发起支付请求后，后端可能成功处理了支付，但响应没有正确返回或请求超时，导致前端收到错误的状态。

##### 面试官问：用户钱付了，订单还是显示未支付，是前端还是后端问题

> 一般可以通过以下方式来定位是前端还是后端问题
>
> 检查后端有没有将支付成功的状态与订单关联（订单表和支付表之间的关联），如果没有关联出现未支付是后端问题（查看支付回调接口日志有没有正确返回请求，以及后端是否正确处理请求没有的话则是后端问题）
>
> 数据库订单状态是否更新
>
> 后端是否返回了支付成功的状态，如果返回了则是前端问题可能前端逻辑处理错误，看后端是否返回了正确的支付状态，返回了则是前端问题可能由于前端页面缓存、未及时刷新或者状态未更新导致的
>
> 检查支付接口的回调日志看是否查看是否得到了正确的响应，如果有则是后端逻辑问题，如果回调接口返回了错误（如超时、500 错误等），支付网关可能认为回调未成功，会尝试重新发送或不再发送，导致支付成功但系统状态未更新

##### 购物车

> 1.用户状态验证
>
> 未登录能不能将商品加入购物车
>
> 1.添加商品
>
> 正常添加商品，购物车是否有该商品以及价格、数量
>
> 2

##### 营销活动测试点

> ### **价格相关测试**
>
> #### 1.1. 商品价格显示测试
>
> - 验证商品页面上显示的原价是否为 100 元。
> - 验证商品页面上显示的促销价格是否为 80 元。
> - 验证促销期间，购物车和结算页显示的价格是否为促销价（80 元）。
> - 验证活动结束后，购物车和结算页是否恢复显示原价（100 元）。
>
> #### 1.2. 价格计算测试
>
> - 验证活动价格的折扣是否正确应用（从 100 元到 80 元）。
> - 验证用户在结算时支付的实际金额是否为 80 元。
>
> ### 2. **购买限制测试**
>
> #### 2.1. 每人限购一件测试
>
> - 同一用户尝试购买多件商品时，验证系统是否限制购买（例如提示“每人限购一件”）。
> - 同一用户分别在多个订单中下单，验证是否只允许一个订单生效。
>
> #### 2.2. 每个手机号限购一件测试
>
> - 使用相同手机号进行多次购买，验证是否只能购买一次。
> - 使用不同手机号但相同用户信息（如相同支付方式或收货地址）进行多次购买，验证是否被系统识别并限制。
>
> ### 3. **时间相关测试**
>
> #### 3.1. 活动时间测试
>
> - 在活动开始时间（早上 8 点）之前，验证商品是否以原价（100 元）显示，且无法以活动价购买。
> - 在活动开始时间（早上 8 点）后，验证商品是否以促销价（80 元）显示，且可以购买。
> - 在活动结束时间（下午 6 点）之后，验证商品是否恢复原价，并限制用户无法再以促销价购买。
> - 测试活动时间的边界值：
>   - **开始前 1 分钟**：无法享受促销价。
>   - **活动开始的准确时间**（如 08:00:00）：享受促销价。
>   - **结束时间的准确时间**（如 18:00:00）：无法享受促销价。
>
> #### 3.2. 时区问题
>
> - 测试跨时区的用户能否在正确的时间段内享受促销价格。
>
> ### 4. **购买流程测试**
>
> - **正常购买流程测试**：用户添加商品到购物车，结算支付，并成功完成订单。
> - **异常情况测试**：用户下单时断网或支付中断，验证订单状态是否处理正确，并且用户是否能够重新购买。
>
> ### 5. **用户状态测试**
>
> - **登录状态**：登录用户是否能够按规则享受促销价并完成购买。
> - **未登录用户**：未登录用户能否购买商品，并在登录后享受相同限制。
> - **切换账号测试**：在同一设备上切换不同用户，是否能再次购买（需结合设备或手机号限制测试）。
>
> ### 6. **库存及订单处理测试**
>
> - **库存限制**：如果该商品有库存限制，验证促销期间是否准确减少库存。
> - **超卖情况**：验证在库存不足时是否还能下单，系统是否正确处理超卖情况（如订单取消或无法下单提示）。
>
> ### 7. **边界测试**
>
> #### 7.1. 边界值测试
>
> - 测试刚好在活动结束时提交订单，验证订单价格是否为活动价或原价。
> - 在活动结束前最后一秒购买，验证是否允许购买。
>
> ### 8. **异常输入测试**
>
> - 使用异常格式的手机号进行下单，验证是否能够成功购买（如不合规的手机号、重复的手机号等）。
> - 输入无效或伪造的用户信息，验证是否能突破限购限制。
>
> ### 9. **性能测试**
>
> - 在促销活动开始时进行并发用户下单测试，验证系统是否能承受高并发访问。
> - 模拟大规模用户同时下单，验证数据库、网络、支付系统的性能及稳定性。
>
> ### 10. **兼容性测试**
>
> - 测试不同设备（手机、平板、PC）、不同操作系统（iOS、Android）和不同浏览器（Chrome、Safari、Firefox）下的活动页面及购买流程是否一致。
>
> ### 11. **支付相关测试**
>
> - **正常支付测试**：测试主流支付方式（如信用卡、微信支付、支付宝）的流程。
> - **支付失败测试**：模拟支付失败或取消支付，验证订单状态是否正确更新，用户是否能重新购买。
>
> ### 12. **安全测试**
>
> - **限制绕过测试**：测试是否能够通过绕过限购（例如使用脚本更改订单信息、多账号登录等方式）。
> - **SQL 注入测试**：验证输入框是否安全，防止 SQL 注入等攻击方式。
>
> ### 13. **日志与追踪**
>
> - 确认下单、支付、库存变动等关键操作是否有足够的日志记录，方便后续分析和调试。
>
> ### 14. **用户体验测试**
>
> - 确认用户在下单、支付过程中有明确的反馈信息（如成功或失败提示，库存不足提示等）。
> - 验证错误提示信息是否清晰明确，指导用户正确操作
